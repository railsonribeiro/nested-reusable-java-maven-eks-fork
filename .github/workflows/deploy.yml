name: Deploy

on:
  workflow_call:
    inputs:
      app_name:
        required: true
        type: string
        description: 'Nome da aplica√ß√£o (ex: orders-api)'
      cluster_name:
        required: true
        type: string
        description: 'Nome do cluster EKS'
      namespace:
        required: true
        type: string
        description: 'Namespace da aplica√ß√£o'
      git_repo_url:
        required: true
        type: string
        description: 'URL do reposit√≥rio Git com os manifestos'
      git_branch:
        required: false
        type: string
        default: main
        description: 'Branch do reposit√≥rio a ser monitorada'
      manifests_path:
        required: false
        type: string
        default: k8s/prd
        description: 'Caminho dos manifestos no reposit√≥rio'
      environment:
        required: false
        type: string
        default: production
        description: 'Ambiente (production, staging, development)'
      region_aws_deploy:
        required: false
        type: string
        default: us-east-1
      argocd_namespace:
        required: false
        type: string
        default: argocd
        description: 'Namespace onde o ArgoCD est√° instalado'

    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
      GIT_TOKEN:
        required: true
        description: 'Token para acessar reposit√≥rios privados do GitHub'

jobs:
  deploy-argocd:
    name: Deploy Application via ArgoCD
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ inputs.region_aws_deploy }}

      - name: Update kube config
        run: |
          echo "üîç Verificando cluster EKS: ${{ inputs.cluster_name }}"
          
          if ! aws eks describe-cluster --name ${{ inputs.cluster_name }} --region ${{ inputs.region_aws_deploy }} >/dev/null 2>&1; then
            echo "‚ùå ERRO: Cluster EKS '${{ inputs.cluster_name }}' n√£o encontrado na regi√£o ${{ inputs.region_aws_deploy }}"
            exit 1
          fi
          
          echo "‚úÖ Cluster encontrado, atualizando kubeconfig..."
          aws eks update-kubeconfig --name ${{ inputs.cluster_name }} --region ${{ inputs.region_aws_deploy }}
          
          echo "üîç Testando conectividade com o cluster..."
          if ! kubectl get nodes >/dev/null 2>&1; then
            echo "‚ùå ERRO: N√£o foi poss√≠vel conectar ao cluster"
            exit 1
          fi
          
          echo "‚úÖ Conectado ao cluster com sucesso!"
          kubectl get nodes

      - name: Create AWS Credentials in Secrets Manager
        run: |
          SECRET_NAME="aws-credentials"
          
          # Verificar se a secret j√° existe
          if aws secretsmanager describe-secret --secret-id "$SECRET_NAME" >/dev/null 2>&1; then
            echo "üîÑ Atualizando secret existente: $SECRET_NAME"
            aws secretsmanager put-secret-value \
              --secret-id "$SECRET_NAME" \
              --secret-string '{"AWS_ACCESS_KEY_ID":"${{ secrets.AWS_ACCESS_KEY_ID }}","AWS_SECRET_ACCESS_KEY":"${{ secrets.AWS_SECRET_ACCESS_KEY }}"}'
          else
            echo "üÜï Criando nova secret: $SECRET_NAME"
            aws secretsmanager create-secret \
              --name "$SECRET_NAME" \
              --description "AWS credentials for applications" \
              --secret-string '{"AWS_ACCESS_KEY_ID":"${{ secrets.AWS_ACCESS_KEY_ID }}","AWS_SECRET_ACCESS_KEY":"${{ secrets.AWS_SECRET_ACCESS_KEY }}"}'
          fi
          
          echo "‚úÖ Secret $SECRET_NAME created/updated in AWS Secrets Manager"
      
      - name: Get AWS Account ID and Role ARN
        id: aws-info
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT
          
          # Buscar a role de secrets manager - nome fixo baseado no cluster
          ROLE_NAME="${{ inputs.cluster_name }}-secrets-manager-access"
          ROLE_ARN=$(aws iam get-role --role-name "$ROLE_NAME" --query "Role.Arn" --output text 2>/dev/null || echo "")
          
          if [ -z "$ROLE_ARN" ] || [ "$ROLE_ARN" == "None" ]; then
            echo "ERROR: Role $ROLE_NAME not found!"
            exit 1
          fi
          
          echo "role_arn=$ROLE_ARN" >> $GITHUB_OUTPUT
          
          echo "AWS Account ID: $ACCOUNT_ID"
          echo "Role ARN: $ROLE_ARN"


      - name: Apply ServiceAccount
        run: |
          # Obter o ARN da role
          ROLE_ARN="${{ steps.aws-info.outputs.role_arn }}"
          echo "Role ARN a ser usado: $ROLE_ARN"
          
          # Criar ServiceAccount diretamente via kubectl
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: ServiceAccount
          metadata:
            name: ${{ inputs.namespace }}-service-account
            namespace: ${{ inputs.namespace }}
            annotations:
              eks.amazonaws.com/role-arn: ${ROLE_ARN}
          EOF
          
          echo "ServiceAccount applied successfully"


      - name: Install ArgoCD CLI
        run: |
          echo "üì¶ Instalando ArgoCD CLI..."
          curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          chmod +x /usr/local/bin/argocd
          argocd version --client

      - name: Get ArgoCD Server URL
        id: argocd_url
        run: |
            echo "üîç Obtendo URL do ArgoCD do cluster..."
            ARGOCD_URL=$(kubectl get svc argocd-server -n ${{ inputs.argocd_namespace }} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
            if [ -z "$ARGOCD_URL" ]; then
              echo "‚ùå ERRO: N√£o foi poss√≠vel obter a URL do ArgoCD"
              exit 1
            fi
            echo "url=$ARGOCD_URL" >> $GITHUB_OUTPUT
            echo "‚úÖ URL do ArgoCD: $ARGOCD_URL"
      
      - name: Get ArgoCD Admin Password
        id: argocd_password
        run: |
          echo "üîê Recuperando senha do admin do ArgoCD do AWS Secrets Manager..."
          SECRET_VALUE=$(aws secretsmanager get-secret-value --secret-id argocd-admin-password --query SecretString --output text)
          
          # Extrair senha do JSON
          ARGOCD_PASSWORD=$(echo "$SECRET_VALUE" | jq -r '.password' | tr -d '\n' | xargs)
          
          if [ -z "$ARGOCD_PASSWORD" ]; then
            echo "‚ùå ERRO: N√£o foi poss√≠vel recuperar a senha do ArgoCD"
            echo "Secret content: $SECRET_VALUE"
            exit 1
          fi
          
          echo "password=$ARGOCD_PASSWORD" >> $GITHUB_OUTPUT
          echo "‚úÖ Senha recuperada com sucesso! (length: ${#ARGOCD_PASSWORD} chars)"
      
      - name: Login to ArgoCD
        env:
          ARGOCD_PASSWORD: ${{ steps.argocd_password.outputs.password }}
        run: |
          echo "üîê Fazendo login no ArgoCD..."
          echo "üîç URL: ${{ steps.argocd_url.outputs.url }}"
          echo "üë§ Username: admin"
          echo "üîë Password length: ${#ARGOCD_PASSWORD} chars"
          
          argocd login ${{ steps.argocd_url.outputs.url }} \
            --username admin \
            --password "$ARGOCD_PASSWORD" \
            --grpc-web \
            --insecure \
            --plaintext
          
          echo "‚úÖ Login realizado com sucesso!"

      - name: Configure Git Repository Access
        run: |
          echo "üîë Configurando acesso ao reposit√≥rio privado..."
          argocd repo add ${{ inputs.git_repo_url }} \
            --username git \
            --password ${{ secrets.GIT_TOKEN }} \
            --insecure-skip-server-verification \
            --upsert
          echo "‚úÖ Reposit√≥rio privado configurado no ArgoCD"

      - name: Create ArgoCD Application
        run: |
          echo "üöÄ Criando/Atualizando aplica√ß√£o no ArgoCD..."
          
          # Criar Application usando ArgoCD CLI
          argocd app create ${{ inputs.app_name }} \
            --repo ${{ inputs.git_repo_url }} \
            --path ${{ inputs.manifests_path }} \
            --dest-server https://kubernetes.default.svc \
            --dest-namespace ${{ inputs.namespace }} \
            --revision ${{ inputs.git_branch }} \
            --sync-policy automated \
            --auto-prune \
            --self-heal \
            --sync-option CreateNamespace=true \
            --grpc-web \
            --upsert \
            || echo "‚ö†Ô∏è  Aplica√ß√£o j√° existe, continuando..."
          
          echo "‚úÖ Aplica√ß√£o criada/atualizada no ArgoCD"

      - name: Display Application URL
        run: |
          echo "========================================="
          echo "‚úÖ Deploy conclu√≠do com sucesso!"
          echo "========================================="
          echo ""
          echo "üîó ArgoCD URL: http://${{ steps.argocd_url.outputs.url }}"
          echo "üìÅ Reposit√≥rio: ${{ inputs.git_repo_url }}"
          echo "üåø Branch: ${{ inputs.git_branch }}"
          echo "========================================="
